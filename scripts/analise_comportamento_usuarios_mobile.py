# -*- coding: utf-8 -*-
"""Analise Comportamento usuarios mobile.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14Xmu4iq3h8b7uHB5k_7IHqImlJupSVUm

## üì±An√°lise do Comportamento de Usu√°rios de Dispositivos M√≥veis
Este projeto utiliza um conjunto de dados que cont√©m padr√µes de uso de dispositivos m√≥veis para classificar o comportamento dos usu√°rios em **cinco categorias**.

### üîãPrincipais Caracter√≠sticas:
- **Tempo di√°rio de uso de aplicativos**, tempo de tela ativa e consumo de bateria.
- **Consumo de dados** e n√∫mero de aplicativos instalados.
- **Demografia dos usu√°rios**: Idade, G√™nero, Modelo do Dispositivo e Sistema Operacional.

### üóÇÔ∏èAplica√ß√µes:
- **Previs√£o do comportamento** dos usu√°rios de dispositivos m√≥veis.
- Identifica√ß√£o de **tend√™ncias de consumo de bateria e dados**.
- Apoio ao **desenvolvimento e otimiza√ß√£o de aplicativos**.


---
"""

import numpy as np
import pandas as pd
import seaborn as sb
import matplotlib.pyplot as plt
import sklearn as skl
import scipy as sp
from sklearn.decomposition import PCA
from sklearn.metrics import adjusted_rand_score, silhouette_score
from sklearn.cluster import KMeans
from sklearn.preprocessing import LabelEncoder, StandardScaler
import kagglehub

file_path = "/content/user_behavior_dataset.csv"
df = pd.read_csv(file_path)

df.head()

df.tail()

"""### üïπÔ∏èExplica√ß√£o da Coluna User Behavior Class (Comportamento de Usu√°rio)
O conjunto de dados classifica os usu√°rios em **cinco categorias** com base em seus padr√µes de uso m√≥vel:

1. **Usu√°rio M√≠nimo**: Uso raro do dispositivo; baixo tempo de uso de aplicativos e consumo de dados.
2. **Usu√°rio Leve**: Uso ocasional para tarefas b√°sicas; tempo de tela moderado.
3. **Usu√°rio M√©dio**: Uso equilibrado para trabalho, redes sociais e entretenimento.
4. **Usu√°rio Intenso**: Alto uso para jogos, streaming ou multitarefa.
5. **Usu√°rio Extremo**: Uso intenso, geralmente para fins profissionais ou jogos.

Essa classifica√ß√£o **√© essencial** para identificar e analisar diferentes tipos de usu√°rios m√≥veis, tornando o conjunto de dados valioso para agrupamento e an√°lise de comportamento.

---

## üåü Pergunta para An√°lise:

**Como os padr√µes de uso de dispositivos m√≥veis podem ser agrupados para identificar diferentes tipos de usu√°rios?**  
   - An√°lise de clusters para explorar e validar a segmenta√ß√£o comportamental existente.
"""

df.info()

"""### üîç Resumo do `info()`

- **Entradas e Colunas:**
  - O dataset cont√©m **700 linhas** e **11 colunas**.

- **Tipos de Dados:**
  - **Num√©ricos:** `App Usage Time`, `Screen On Time`, `Battery Drain`, `Number of Apps Installed`, `Data Usage`, `Age`.
  - **Categ√≥ricos:** `Device Model`, `Operating System`, `Gender`, `User Behavior Class`.

- **Valores Nulos:**
  - **N√£o h√° valores ausentes**. Todas as colunas possuem 700 entradas v√°lidas.

- **Tamanho da Mem√≥ria:**
  - O dataset ocupa **60.3 KB** de mem√≥ria, tornando-o leve e f√°cil de processar.

---

### üí° Implica√ß√µes
1. **Colunas Num√©ricas:**
   - Podem ser usadas diretamente em an√°lises estat√≠sticas ou para identificar correla√ß√µes.

2. **Colunas Categ√≥ricas:**
   - Precisam ser codificadas para an√°lises avan√ßadas ou uso em modelos de machine learning.

3. **Dataset Completo:**
   - Sem valores ausentes, reduzindo a necessidade de pr√©-processamento.

4. **Efici√™ncia:**
   - O pequeno tamanho do dataset permite an√°lises r√°pidas mesmo em dispositivos com menor capacidade computacional.

"""

df.describe().transpose()

"""# üìä Resumo Estat√≠stico das Vari√°veis

A an√°lise descritiva das vari√°veis do dataset fornece insights importantes sobre os padr√µes de uso de dispositivos m√≥veis. O conjunto de dados cont√©m **700 amostras** no total. Abaixo est√£o as principais estat√≠sticas de cada coluna:

| **Vari√°vel**                   | **M√©dia**  | **Desvio Padr√£o** | **M√≠nimo** | **25%**   | **50% (Mediana)** | **75%**   | **M√°ximo** |
|--------------------------------|------------|-------------------|------------|-----------|-------------------|-----------|------------|
| **Tempo de Uso de Aplicativos (min/dia)** | 271.13     | 177.20           | 30.0       | 113.25    | 227.5             | 434.25    | 598.0      |
| **Tempo de Tela Ativa (horas/dia)** | 5.27       | 3.07             | 1.0        | 2.50      | 4.9               | 7.40      | 12.0       |
| **Consumo de Bateria (mAh/dia)** | 1525.16    | 819.14           | 302.0      | 722.25    | 1502.5            | 2229.50   | 2993.0     |
| **N√∫mero de Aplicativos Instalados** | 50.68      | 26.94            | 10.0       | 26.00     | 49.0              | 74.00     | 99.0       |
| **Consumo de Dados (MB/dia)**   | 929.74     | 640.45           | 102.0      | 373.00    | 823.5             | 1341.00   | 2497.0     |
| **Idade**                      | 38.48      | 12.01            | 18.0       | 28.00     | 38.0              | 49.00     | 59.0       |
| **Classe de Comportamento do Usu√°rio** | 2.99       | 1.40             | 1.0        | 2.00      | 3.0               | 4.00      | 5.0        |

---

### üîç Conclus√µes

1. **Tempo de Uso de Aplicativos e Tempo de Tela Ativa**:
   - O tempo m√©dio di√°rio de uso de aplicativos √© de **271 minutos** (4 horas e 31 minutos), enquanto o tempo m√©dio de tela ativa √© de **5,27 horas**.
   - A alta varia√ß√£o no uso de aplicativos (desvio padr√£o de 177,2) indica perfis de usu√°rios muito distintos.

2. **Consumo de Bateria e N√∫mero de Aplicativos Instalados**:
   - O consumo m√©dio de bateria √© de **1525 mAh por dia**, com usu√°rios mais intensos atingindo quase **3000 mAh**.
   - O n√∫mero m√©dio de aplicativos instalados √© **50,68**, variando de 10 a 99.

3. **Consumo de Dados**:
   - O consumo m√©dio di√°rio de dados √© de **929,74 MB**, com usu√°rios extremos consumindo at√© **2,5 GB por dia**.

4. **Idade dos Usu√°rios**:
   - A idade m√©dia dos usu√°rios √© **38,48 anos**, com a maioria na faixa de **28 a 49 anos**.

5. **Classe de Comportamento**:
   - As classes de comportamento apresentam uma distribui√ß√£o equilibrada com uma mediana de **3**, representando um usu√°rio m√©dio.

---

### üí° Implica√ß√µes

- **Identifica√ß√£o de Padr√µes**:
   - As grandes varia√ß√µes no consumo de bateria e dados sugerem a exist√™ncia de diferentes perfis de usu√°rios, o que ser√° explorado na an√°lise de clusters.
- **Uso de Recursos**:
   - O alto consumo de bateria e dados entre os usu√°rios mais intensos destaca a necessidade de otimiza√ß√£o em dispositivos m√≥veis e aplicativos para melhorar a efici√™ncia.
- **Segmenta√ß√£o Demogr√°fica**:
   - A faixa et√°ria predominante pode orientar o design de aplicativos e estrat√©gias de marketing.

---

## üîß Remo√ß√£o da Coluna `User ID`

A coluna `User ID` foi removida por ser irrelevante para o processo de clustering. Como ela n√£o possui rela√ß√£o direta com o comportamento ou caracter√≠sticas dos usu√°rios, sua presen√ßa pode apenas adicionar ru√≠do ao modelo, prejudicando a qualidade dos clusters.


---
"""

# Remover colunas irrelevantes
df = df.drop(columns=['User ID'])

"""---

## üñ≤Ô∏è Verifica√ß√£o de Outliers

Realizamos uma an√°lise do intervalo interquartil (IQR) para verificar a presen√ßa de outliers nos dados. A an√°lise de outliers √© essencial para garantir que valores extremos n√£o prejudiquem a qualidade do modelo.

### M√©todo Utilizado:
O IQR foi calculado para cada coluna num√©rica, e os outliers foram identificados como valores fora do intervalo:
"""

numerical_columns = ['App Usage Time (min/day)', 'Screen On Time (hours/day)',
                     'Battery Drain (mAh/day)', 'Number of Apps Installed',
                     'Data Usage (MB/day)', 'Age']

for col in numerical_columns:
    Q1 = df[col].quantile(0.25)
    Q3 = df[col].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR

    outliers = df[(df[col] < lower_bound) | (df[col] > upper_bound)]
    print(f"Coluna {col}: {len(outliers)} outliers")

bins = [18, 25, 35, 45, 60]
labels = ['18-25', '26-35', '36-45', '46-60']
df['Age Group'] = pd.cut(df['Age'], bins=bins, labels=labels, right=False)
print(df['Age Group'].unique())  # Verifique os grupos

"""---

## ‚öôÔ∏è Normaliza√ß√£o dos Dados

Para garantir que todas as vari√°veis num√©ricas estejam na mesma escala e sejam adequadamente consideradas nos c√°lculos do modelo, realizamos a normaliza√ß√£o dos dados usando **StandardScaler**.

### Por que Normalizar?
- Vari√°veis em escalas diferentes podem influenciar os algoritmos de aprendizado, como o clustering.
- A normaliza√ß√£o padroniza os dados para que tenham m√©dia 0 e desvio padr√£o 1.

### M√©todo Utilizado:
Utilizamos a biblioteca `StandardScaler` do scikit-learn para transformar as colunas num√©ricas. Cada valor foi ajustado pela f√≥rmula:
"""

scaler = StandardScaler()
df[numerical_columns] = scaler.fit_transform(df[numerical_columns])

"""---

## üîÑ Codifica√ß√£o de Dados Categ√≥ricos

Para que os algoritmos de aprendizado de m√°quina possam interpretar vari√°veis categ√≥ricas, realizamos a codifica√ß√£o dessas colunas em valores num√©ricos usando o **LabelEncoder**.

### üßë‚ÄçüíªPor que Codificar?
- Algoritmos como o k-means n√£o conseguem operar diretamente com dados categ√≥ricos.
- Transformar esses dados em valores num√©ricos permite que sejam utilizados em c√°lculos e an√°lises.

### üîåColunas Codificadas:
- **Gender** (G√™nero)
- **Operating System** (Sistema Operacional)
- **Device Model** (Modelo do Dispositivo)

### C√≥digo Utilizado:
Transformamos as colunas com o seguinte trecho de c√≥digo:
"""

df['Gender'] = LabelEncoder().fit_transform(df['Gender'])
df['Operating System'] = LabelEncoder().fit_transform(df['Operating System'])
df['Device Model'] = LabelEncoder().fit_transform(df['Device Model'])

print(df.dtypes) #Verificando se foi convertido corretamente

"""---

## üè∑Ô∏è An√°lise de Classes Existentes

Antes de aplicar o clustering, exploramos as classes pr√©-definidas no dataset para entender a distribui√ß√£o das entradas.

### C√≥digo:
"""

classes = df['User Behavior Class'].unique()

# Subconjuntos por classe
subsets = {cls: df[df['User Behavior Class'] == cls] for cls in classes}

# Visualizar o tamanho de cada subconjunto
for cls, subset in subsets.items():
    print(f"Classe {cls}: {len(subset)} entradas")

"""---
## üéØ **Quais s√£o os diferentes tipos de usu√°rios m√≥veis com base em seus padr√µes de comportamento?**

### üóÉÔ∏è **Modelo Sugerido: Clustering (n√£o supervisionado)**

Para identificar padr√µes de comportamento entre os usu√°rios, utilizei o algoritmo de **K-Means Clustering**, agrupando os usu√°rios com base nas seguintes vari√°veis comportamentais:

- **Tempo de Uso de Aplicativos (min/dia)**  
- **Tempo de Tela Ativa (horas/dia)**  
- **Consumo de Dados (MB/dia)**  
- **Consumo de Bateria (mAh/dia)**  
- **N√∫mero de Aplicativos Instalados**  

### üîç **Etapas da An√°lise:**
1. **Normaliza√ß√£o dos Dados**:  
   Todas as vari√°veis num√©ricas foram escaladas para garantir que tenham a mesma influ√™ncia no agrupamento.
   
2. **Defini√ß√£o do N√∫mero de Clusters**:  
   Escolhi **5 clusters**, alinhando-se √†s classes comportamentais previamente fornecidas para compara√ß√£o.

3. **Visualiza√ß√£o dos Clusters**:  
   Realizei uma redu√ß√£o de dimensionalidade utilizando PCA (Principal Component Analysis) para projetar os clusters em duas dimens√µes e facilitar a interpreta√ß√£o visual.

4. **Avalia√ß√£o do Modelo**:  
   O desempenho do clustering foi avaliado usando o **Silhouette Score**, que mediu a qualidade da separa√ß√£o entre os clusters.
"""

# Selecionar colunas num√©ricas relevantes para clustering
X = df[['App Usage Time (min/day)', 'Screen On Time (hours/day)',
        'Battery Drain (mAh/day)', 'Number of Apps Installed', 'Data Usage (MB/day)']]

# Definir o n√∫mero de clusters (5, com base nas classes de comportamento)
kmeans = KMeans(n_clusters=5, random_state=42)
kmeans.fit(X)

# Adicionar os r√≥tulos ao dataset
df['Cluster'] = kmeans.labels_

# Visualizar contagem por cluster
print(df['Cluster'].value_counts())

"""---
# üíªCompara√ß√£o entre Classes e Clusters
"""

# Compara√ß√£o entre classes originais e clusters gerados
comparison = pd.crosstab(df['User Behavior Class'], df['Cluster'])
print(comparison)

"""### üßÆ Compara√ß√£o entre Classes e Clusters

Ao comparar as classes originais de comportamento do usu√°rio com os clusters gerados pelo modelo de clustering, observamos uma **correspond√™ncia quase perfeita**. Isso significa que o modelo de clustering, com base nas vari√°veis fornecidas, praticamente replicou as classes existentes.

---

#### üîç Detalhes da Compara√ß√£o:

**Classes Originais:**
- Classe 1: 136 entradas  
- Classe 2: 146 entradas  
- Classe 3: 143 entradas  
- Classe 4: 139 entradas  
- Classe 5: 136 entradas  

**Clusters Gerados:**
- Cluster 0: 136 entradas  
- Cluster 1: 146 entradas  
- Cluster 2: 143 entradas  
- Cluster 3: 136 entradas  
- Cluster 4: 139 entradas  

---

#### üìä Tabela de Conting√™ncia:
A tabela de conting√™ncia abaixo confirma que cada cluster corresponde diretamente a uma classe original:

| Cluster | Classe 1 | Classe 2 | Classe 3 | Classe 4 | Classe 5 |
|---------|----------|----------|----------|----------|----------|
| 0       | 0        | 0        | 0        | 0        | 136      |
| 1       | 0        | 146      | 0        | 0        | 0        |
| 2       | 0        | 0        | 143      | 0        | 0        |
| 3       | 136      | 0        | 0        | 0        | 0        |
| 4       | 0        | 0        | 0        | 139      | 0        |

---

#### üìà Conclus√£o:
O modelo de clustering **replicou perfeitamente** as classes originais. Isso sugere que:
1. As vari√°veis escolhidas representam fielmente o comportamento dos usu√°rios.
2. A aplica√ß√£o de clustering neste caso apenas confirma a separa√ß√£o j√° existente nas classes originais.

---
#ü§ñ Avalia√ß√£o de Qualidade dos Clusters: Silhouette Score
"""

score = silhouette_score(X, kmeans.labels_)
print(f"Silhouette Score: {score:.2f}")

"""### üßÆ Avalia√ß√£o do Clustering com Silhouette Score

O **Silhouette Score** √© uma m√©trica amplamente utilizada para avaliar a qualidade de agrupamentos gerados por algoritmos de clustering. Ele mede a separa√ß√£o entre os clusters e a coes√£o dentro deles, com valores variando de -1 a 1. Quanto mais pr√≥ximo de 1, melhor a separa√ß√£o e defini√ß√£o dos clusters.

No nosso caso, o **Silhouette Score foi de 0.60**. Este valor indica que os clusters gerados pelo modelo t√™m uma qualidade moderada:

- **Coes√£o:** Os pontos est√£o razoavelmente pr√≥ximos ao centro de seus pr√≥prios clusters.
- **Separa√ß√£o:** Os clusters t√™m uma separa√ß√£o vis√≠vel, mas h√° alguma sobreposi√ß√£o entre eles.

---

### üîç Interpreta√ß√£o

Embora o **Silhouette Score** de 0.60 indique que o modelo conseguiu capturar uma estrutura de agrupamento nos dados, ele n√£o reflete uma separa√ß√£o perfeitamente clara entre os clusters. Isso pode ser devido a:
1. **Caracter√≠sticas dos Dados:** Algumas vari√°veis podem n√£o contribuir significativamente para a separa√ß√£o dos grupos.
2. **Geometria dos Clusters:** Os clusters podem n√£o ser perfeitamente esf√©ricos, o que pode reduzir o Silhouette Score.
3. **Correspond√™ncia com Classes Originais:** O modelo replicou bem as classes originais, mas o Silhouette Score n√£o mede diretamente esse alinhamento.

---

### ‚ö†Ô∏è Limita√ß√£o do Silhouette Score

O **Silhouette Score** avalia apenas a separa√ß√£o geom√©trica e n√£o considera a correspond√™ncia com as classes originais. Por isso, mesmo com um alinhamento perfeito entre os clusters e as classes, o valor pode ser moderado, como no caso atual.

---

### üìå Conclus√£o

Embora o **Silhouette Score** seja √∫til, ele deve ser complementado com outras m√©tricas, como:
- **Adjusted Rand Index (ARI):** Mede o alinhamento entre clusters e classes.
- **Calinski-Harabasz Index (CH):** Avalia a dispers√£o dos clusters.

Dessa forma, podemos obter uma an√°lise mais completa e robusta da qualidade do agrupamento gerado.

"""

# Calcular o Adjusted Rand Index (ARI)
ari_score = adjusted_rand_score(df['User Behavior Class'], df['Cluster'])

print(f"Adjusted Rand Index (ARI): {ari_score:.4f}")

"""### üî¢ Avalia√ß√£o com Adjusted Rand Index (ARI)

O **Adjusted Rand Index (ARI)** foi utilizado para medir a correspond√™ncia entre os clusters gerados pelo modelo de clustering e as classes originais de comportamento do usu√°rio.

üìä **Resultado:**
O valor calculado para o ARI foi **1.00**, indicando que os clusters gerados correspondem perfeitamente √†s classes originais.

üìã **Interpreta√ß√£o:**
Um ARI igual a **1.00** significa que o modelo de clustering replicou exatamente as divis√µes das classes originais. Isso confirma que os padr√µes identificados pelo modelo de clustering est√£o completamente alinhados com os r√≥tulos fornecidos no dataset.

‚öôÔ∏è **Conclus√£o:**
Embora o Silhouette Score tenha indicado uma moderada coes√£o e separa√ß√£o dos clusters (0.60), o ARI confirma que os clusters gerados pelo modelo s√£o consistentes e correspondem diretamente √†s classes originais. Esse resultado refor√ßa que as vari√°veis escolhidas para o clustering capturam bem o comportamento dos usu√°rios e que o modelo segmentou os dados de forma precisa.

üí° Observa√ß√£o: O Silhouette Score avalia apenas a separa√ß√£o geom√©trica entre os clusters, enquanto o ARI mede o alinhamento entre os clusters e as classes originais. Apesar de um Silhouette Score moderado, o ARI confirma que os clusters est√£o perfeitamente alinhados com as classes pr√©-definidas.

---
#üñºÔ∏è Visualiza√ß√£o dos Clusters com PCA
"""

pca = PCA(n_components=2)
X_pca = pca.fit_transform(X)

plt.scatter(X_pca[:, 0], X_pca[:, 1], c=kmeans.labels_, cmap='viridis')
plt.title('Clusters de Usu√°rios')
plt.xlabel('Componente Principal 1')
plt.ylabel('Componente Principal 2')
plt.colorbar()
plt.show()

plt.savefig('results/cluster_visualization.png')

"""---
# üìâAn√°lise do Gr√°fico de Clusters (PCA)

O gr√°fico de dispers√£o com PCA mostra os clusters identificados projetados em duas dimens√µes.  
As cores representam os diferentes clusters, com a barra de cores indicando os r√≥tulos dos clusters.  

## Observa√ß√µes:
1. **Separa√ß√£o clara:** Os clusters est√£o bem separados no gr√°fico, indicando que o modelo conseguiu distinguir padr√µes nos dados.  
2. **Varia√ß√£o entre pontos:** H√° varia√ß√£o consider√°vel nas posi√ß√µes dos pontos, sugerindo que os clusters representam comportamentos distintos de uso.  
3. **Efic√°cia do PCA:** A separa√ß√£o visual entre os clusters confirma a efic√°cia da redu√ß√£o de dimensionalidade pelo PCA, tornando mais f√°cil interpretar os resultados.  

"""

cluster_stats = df.groupby('Cluster').agg({col: 'mean' for col in df.select_dtypes(include=np.number).columns})
print(cluster_stats)

"""---
# üöÄAn√°lise dos Resultados dos Clusters

Ap√≥s o agrupamento, os clusters foram analisados com base na m√©dia das vari√°veis em cada grupo. Os resultados mostram diferen√ßas distintas nos padr√µes de uso entre os clusters.

- **Cluster 0:** Usu√°rios com **alta m√©dia de uso di√°rio de aplicativos** e tempo de tela. Apresentam **drenagem de bateria acima da m√©dia**, indicando poss√≠vel uso intensivo de apps ou dispositivos com maior consumo energ√©tico.

- **Cluster 1:** Usu√°rios com **uso moderado de aplicativos** e **tempo de tela negativo** (abaixo da m√©dia geral). O consumo de bateria e o n√∫mero de aplicativos instalados tamb√©m s√£o reduzidos.

- **Cluster 2:** Apresenta valores m√©dios pr√≥ximos da neutralidade, indicando um perfil mais **balanceado**, com caracter√≠sticas que n√£o se destacam significativamente.

- **Cluster 3:** Caracteriza usu√°rios com **baixo consumo de bateria, apps instalados e uso de dados**, provavelmente indicando **uso moderado ou limitado do dispositivo.**

- **Cluster 4:** Usu√°rios com **m√©dia alta de uso di√°rio de aplicativos e dados**, mas com consumo de bateria moderado. Demonstram um perfil que equilibra uso intensivo e efici√™ncia energ√©tica.

Essa an√°lise ajuda a identificar padr√µes de comportamento que podem ser √∫teis para campanhas direcionadas, otimiza√ß√£o de recursos ou recomenda√ß√µes personalizadas.

---
### üí° Alternativa: Clustering sem Influ√™ncia Direta das Classes Originais

Nesta se√ß√£o, realizamos uma nova an√°lise de clustering com o objetivo de garantir que os agrupamentos gerados pelo modelo sejam completamente independentes das classes originais fornecidas no conjunto de dados. Para isso, removemos a coluna `User Behavior Class` antes de realizar o clustering, evitando qualquer influ√™ncia direta desta vari√°vel.

#### üöÄ M√©todo
- **Remo√ß√£o da Coluna:** A coluna `User Behavior Class` foi exclu√≠da do conjunto de dados antes do processo de clustering.
- **Vari√°veis Utilizadas:** Foram selecionadas as colunas num√©ricas relacionadas ao comportamento de uso de dispositivos m√≥veis, como tempo de uso de aplicativos e consumo de bateria.
- **Normaliza√ß√£o dos Dados:** Aplicamos o `StandardScaler` para garantir que todas as vari√°veis num√©ricas estivessem na mesma escala.
- **Algoritmo Utilizado:** Usamos o K-Means com 5 clusters, alinhado ao n√∫mero de grupos esperados.
"""

# Atualizar o conjunto de dados removendo a coluna 'User Behavior Class'
X_new = df.drop(columns=['User Behavior Class'])

# Selecionar apenas as colunas num√©ricas relevantes para clustering
numerical_columns = ['App Usage Time (min/day)', 'Screen On Time (hours/day)',
                     'Battery Drain (mAh/day)', 'Number of Apps Installed', 'Data Usage (MB/day)']
X_new = X_new[numerical_columns]

# Normalizar os dados novamente
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X_new)

# Refazer o clustering com K-Means
kmeans = KMeans(n_clusters=5, random_state=42)
kmeans.fit(X_scaled)

# Adicionar os novos r√≥tulos ao dataset
df['New Cluster'] = kmeans.labels_

# Avaliar os clusters
silhouette_new = silhouette_score(X_scaled, kmeans.labels_)
print(f"Novo Silhouette Score: {silhouette_new:.2f}")

# Calcular o Adjusted Rand Index (ARI)
ari_score = adjusted_rand_score(df['User Behavior Class'], df['Cluster'])

print(f"Adjusted Rand Index (ARI): {ari_score:.4f}")

"""### üìä Resultados da Nova An√°lise de Clustering

Ap√≥s realizar o clustering sem a influ√™ncia da coluna original `User Behavior Class`, obtivemos os seguintes resultados:

- **Silhouette Score:** 0.60  
  O Silhouette Score permanece o mesmo, indicando uma qualidade moderada de separa√ß√£o e coes√£o dos clusters. Este resultado refor√ßa que a estrutura geom√©trica dos dados ainda apresenta alguma sobreposi√ß√£o entre os grupos, mas identifica padr√µes relevantes.

- **Adjusted Rand Index (ARI):** 1.0000  
  O ARI perfeito indica que, mesmo sem a influ√™ncia direta da coluna de classes originais, os clusters gerados pelo modelo de clustering replicaram exatamente a segmenta√ß√£o previamente existente.

#### üìà Conclus√£o
A an√°lise demonstra que as vari√°veis escolhidas para o clustering representam fielmente o comportamento dos usu√°rios. A correspond√™ncia perfeita entre clusters e classes sugere que o modelo foi capaz de identificar com precis√£o os padr√µes comportamentais, mesmo sem informa√ß√µes pr√©vias de r√≥tulos.

Este resultado valida a robustez das vari√°veis selecionadas e refor√ßa a aplicabilidade do modelo em contextos reais, como a identifica√ß√£o de grupos de usu√°rios com base em dados n√£o rotulados.

## üìÇ Fonte do Dataset

Este projeto utilizou o conjunto de dados **"Mobile Device Usage and User Behavior Dataset"**, dispon√≠vel no Kaggle.  

üîó **Link para o Dataset:** [Mobile Device Usage and User Behavior Dataset](https://www.kaggle.com/datasets/valakhorasani/mobile-device-usage-and-user-behavior-dataset)

üìú **Descri√ß√£o do Dataset**:  
O dataset fornece informa√ß√µes detalhadas sobre o comportamento de usu√°rios de dispositivos m√≥veis, incluindo tempo de uso, consumo de bateria, dados demogr√°ficos, entre outros. √â uma excelente base para an√°lise de padr√µes de comportamento e segmenta√ß√£o de usu√°rios.

üôå **Agradecimento**:  
Agradecemos aos criadores do dataset por disponibilizarem essa valiosa fonte de dados para a comunidade.
"""

